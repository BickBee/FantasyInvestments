package com.example.fantasystocks.database

import com.example.fantasystocks.TRANSACTION_FEE
import io.github.jan.supabase.postgrest.from
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import kotlinx.serialization.Serializable

@Serializable
data class Transaction(
        val txn_id: Int? = null, // Auto-generated by database
        val uid: String,
        val league_id: Int,
        val stock_id: Int,
        val action: String, // "BUY" or "SELL"
        val quantity: Double,
        val price: Double,
        val timestamp: String = java.time.LocalDateTime.now().toString(),
        val transaction_fee: Double
)

object TransactionRouter {
    private val databaseConnector = SupabaseClient
    private const val TRANSACTION_TABLE_NAME = "transactions"

    suspend fun createTransaction(transaction: Transaction): Result<Unit> =
            withContext(Dispatchers.IO) {
                try {
                    val userCash =
                            SessionRouter.getSessionBalance(transaction.league_id, transaction.uid)
                    val stockQuantity =
                            StockRouter.getStockQuantity(
                                    transaction.league_id,
                                    transaction.uid,
                                    transaction.stock_id
                            )


                    val postTransactionBalance: Double =
                            when (transaction.action) {
                                "BUY" -> {
                                    userCash -
                                            (transaction.quantity * transaction.price) -
                                            transaction.transaction_fee
                                }
                                "SELL" -> {
                                    userCash + (transaction.quantity * transaction.price) -
                                            transaction.transaction_fee
                                }
                                else -> {
                                    return@withContext Result.failure(
                                            IllegalArgumentException(
                                                    "Invalid transaction action: ${transaction.action}"
                                            )
                                    )
                                }
                            }

                    // Calculate new stock quantity based on the transaction action.
                    // Note: Remove any accidental extra computation (the extra line in your BUY
                    // branch).
                    val postTransactionStockQuantity: Double =
                            when (transaction.action) {
                                "BUY" -> {
                                    stockQuantity + transaction.quantity
                                }
                                "SELL" -> {
                                    stockQuantity - transaction.quantity
                                }
                                else -> {
                                    return@withContext Result.failure(
                                            IllegalArgumentException(
                                                    "Invalid transaction action: ${transaction.action}"
                                            )
                                    )
                                }
                            }

                    // Ensure that the user has enough cash and stock quantity.
                    if (postTransactionBalance < 0 || postTransactionStockQuantity < 0) {
                        return@withContext Result.failure(
                                IllegalStateException("Insufficient funds or stock quantity")
                        )
                    }

                    println("Transaction: $transaction")
                    databaseConnector.supabase.from(TRANSACTION_TABLE_NAME).insert(transaction) {
                        select()
                    }

                    StockRouter.updateSessionStockQuantity(
                            transaction.uid,
                            transaction.league_id,
                            transaction.stock_id,
                            postTransactionStockQuantity
                    )
                    SessionRouter.updateSessionBalance(
                            transaction.uid,
                            transaction.league_id,
                            postTransactionBalance
                    )

                    Result.success(Unit)
                } catch (e: Exception) {
                    e.printStackTrace()
                    Result.failure(e)
                }
            }

    suspend fun getStockTransactionsForUser(
            uid: String,
            leagueId: Int,
            stockId: Int
    ): List<Transaction> {

        val stockTransactions =
                databaseConnector
                        .supabase
                        .from(TRANSACTION_TABLE_NAME)
                        .select {
                            filter {
                                eq("stock_id", stockId)
                                eq("uid", uid)
                                eq("league_id", leagueId)
                            }
                        }
                        .decodeList<Transaction>()

        stockTransactions.forEach { transaction -> println("Transaction: $transaction") }

        return stockTransactions
    }
}
